# 정리

## zip()

```zip()```함수는 ```iterable``` 객체를 인자로 받아서 사용

동일한 개수로 이루어진 자료형을 ```index``` 순서데 따라 묶어준다.

```zip()```

- 동일한 개수로 이루어진 자료형을 묶어 주는 역할을 하는 함수
- 여러 그룹의 데이터를 동시에 반복문으로 처리할 수 있다. 
- 가장 짧은 데이터 길이만큼 반복된다.

~~~python
a = ['one', 'two', 'three']
b = ['a', 'b', 'c']
list(zip(a, b))
>>> [('one', 'a'), ('two', 'b'), ('three', 'c')]
~~~

**Ex) 프로그래머스 Level1. 음양 더하기**

~~~python
def solution(absolutes, signs):
	answer = 0
	
	for absolute, sign in zip(absolutes, signs):
		if sign:
			answer += absolute
		else:
			answer -= absolute
	return answer
~~~



## combinations() 

combination : 조합

**조건** : ```from itertools import combinations```

하나의 리스트에서, 순서를 고려하지 않고, 중복없이 뽑을 경우의 수

````python
from itertools import combinations
list(combinations(item, 2))

import itertools
itertools.combinations(item,2)
````

**Ex) 프로그래머스 Level1. 소수 만들기**

````python
from itertools import combinations

def solution(nums):
    answer = 0
    
    for i in combinations(nums, 3):
        s = sum(i)
        count = 0
        for j in range(2, s):
        	if s % j == 0:
            	count += 1
            	break
        if count == 0:
            answer += 1
    
    return answer
````



## permutation()

permutation : 순열

조건 : ```from itertools import permutations```

하나의 리스트에서, 순서를 고려하고, 중복없이 뽑을 경우의 수

```python
from itertools import permutations
list(permutations(item, 2))
```



## collections()

```collections``` 모듈의 ```Counter``` 클래스

**조건** : `from collections import Counter `      

> 이해하기

llist를 가지고 Counter를 생성하면, Counter는 Key가 이름이고, Value가 count인 diconarty 반환

| Key  | Value |
| ---- | ----- |
| C    | 1     |
| A    | 1     |
| B    | 1     |

- first list를 Counter로 만들었을 때의 결과값

| Key  | Value |
| ---- | ----- |
| C    | 1     |
| B    | 1     |

- second list를 Counter로 만들었을 때의 결과값

> 결과값 확인

````python
collections.Counter(first) - collections.Counter(completion)	
````

| Key  | Value |
| ---- | ----- |
| A    | 1     |

- Counter class는 상호간의 뺄셈 연산은 지원한다.
- 즉, 뺄셈 연산 한번으로 차이 결과값을 얻을 수 있다.

> Counter에서 Key값을 읽어오기

- 결과값은 `dictionary`형식이기 때문에, Key값이 필요할 때는
- <mark>list(answer.keys())[0]</mark>
  - answer로 부터 Keys를 꺼내온다
  - Keys를 list로 형변환 하고
  - 이 중 0번 째 인덱스의 값을 읽어온다

**Ex) 프로그래머스 Level1. 완주하지 못한 선수**

````python
import collections

def solution(participant, completion):
	answer = collections.Counter(participant) - collections.Counter(completion)
    return list(answer.keys())[0]
````



## enumerate()

enumerate = 열거하다

List , Tuple , String 등 여러가지 자료형을 입력받으면 인덱스 값을 포함하는 enumerate 객체를 돌려준다.

````python
item = ["First", "Second", "Third"]

for i in enumerate(item):
	print(i)

# 실행결과
(0, 'First')
(1, 'Second')
(2, 'Third')
````

```python
a = [1, 2, 3, 4, 5]

list(enumerate(a))

# 실행결과
[(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]  # (앞 = 인덱스, 뒤 = 값)
```

````python
# 리스트a의 값과 인덱스 함께 출력하는 방법
a = ['a1', 'b1', 'c3']

# 1)
for i in range(len(a)):
    print(i, a[i])

# 2)
for i, j in enumerate(a):
    print(i, j)
    
# 실행결과
0 a1
1 b1
2 c3

# 3)
for i in enumerate(a):
    print(i)

# 실행결과
(0, 'a1')
(1, 'b1')
(2, 'c3')
````

**Ex) 프로그래머스 Level1. 모의고사**

```python
def solution(answers):
    answer = []
    score = [0, 0, 0]

    first = [1, 2, 3, 4, 5]
    second = [2, 1, 2, 3, 2, 4, 2, 5]
    third = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
    
    for i, answer in enumerate(answers):
        if answer == first[i % len(first)]:
            score[0] += 1
        if answer == second[i % len(second)]:
            score[1] += 1
        if answer == third[i % len(third)]:
            score[2] += 1
    
    for i, s in enumerate(score):
        if s == max(score):
            answer.append(i + 1)
    
    return answer
```



